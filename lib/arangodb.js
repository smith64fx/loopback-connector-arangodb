// Generated by CoffeeScript 1.12.3
var ArangoDBConnector, Connector, GeoPoint, _, _fieldIncluded, arangojs, async, debug, generateConnObject, initializeDataSource, merge, qb, url,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

arangojs = require('arangojs');

qb = require('aqb');

url = require('url');

merge = require('extend');

async = require('async');

_ = require('underscore');

Connector = require('loopback-connector').Connector;

GeoPoint = require('loopback-datasource-juggler').GeoPoint;

debug = require('debug')('loopback:connector:arango');

exports.generateConnObject = generateConnObject = function(settings) {
  var u;
  u = {};
  u.protocol = settings.protocol || 'http:';
  u.hostname = settings.hostname || settings.host || '127.0.0.1';
  u.port = settings.port || 8529;
  if (settings.username && settings.password) {
    u.auth = settings.username + ":" + settings.password;
  }
  settings.databaseName = settings.database || settings.db || 'test';
  settings.promise = settings.promise || false;
  return url.format(u);
};


/*
  Decide if field should be included
  @param {Object} fields
  @param {String} fieldName
  @returns {Boolean}
  @private
 */

_fieldIncluded = function(fields, fieldName) {
  var f, i, len;
  if (!fields) {
    return true;
  }
  if (Array.isArray(fields)) {
    return fields.indexOf(fieldName >= 0);
  }
  if (fields[fieldName]) {
    return true;
  }
  if (indexOf.call(fields, fieldName) >= 0 && !fields[fieldName]) {
    return false;
  }
  for (i = 0, len = fields.length; i < len; i++) {
    f = fields[i];
    return !fields[f];
  }
  return true;
};


/*
  Initialize the ArangoDB connector for the given data source
  @param dataSource [DataSource] The data source instance
  @param callback [Function] The callback function
 */

initializeDataSource = function(dataSource, callback) {
  var s;
  if (!arangojs) {
    return;
  }
  s = dataSource.settings;
  s.url = s.url || generateConnObject(s);
  dataSource.connector = new ArangoDBConnector(s, dataSource);
  if (callback != null) {
    return dataSource.connector.connect(callback);
  }
};

exports.initialize = initializeDataSource;


/*
  Loopback Arango Connector
  @extend Connector
 */

ArangoDBConnector = (function(superClass) {
  extend(ArangoDBConnector, superClass);


  /*
    The constructor for ArangoDB connector
    @constructor
    @param dataSource [Object] Object to connect this connector to a data source
    @option settings host [String] The host/ip address to connect with
    @option settings port [Number] The port to connect with
    @option settings database/db [String] The database to connect with
    @option settings headers [Object] Object with header to include in every request
    @param dataSource [DataSource] The data source instance
   */

  function ArangoDBConnector(settings, dataSource) {
    ArangoDBConnector.__super__.constructor.call(this, 'arangodb', settings);
    this.debug = dataSource.settings.debug || debug.enabled;
    this.dataSource = dataSource;
    this.qb = qb;
    this.returnVariable = 'result';
  }


  /*
    Connect to ArangoDB
    @param callback [Function] The callback function, called the with created connection
   */

  ArangoDBConnector.prototype.connect = function(callback) {
    if (this.debug) {
      debug("ArangoDB connection is called with settings: " + (JSON.stringify(this.settings)));
    }
    if (!this.db) {
      this.db = arangojs(this.settings);
      this.api = this.db.route('/_api');
    }
    return process.nextTick(function() {
      return callback && callback(null, this.db);
    });
  };


  /*
    Get the types of this connector
    @return [Array<String>] The types of connectors this connector belongs to
   */

  ArangoDBConnector.prototype.getTypes = function() {
    return ['db', 'nosql', 'arangodb'];
  };


  /*
    The default Id type
    @return [Object] The class to build the Id Value with
   */

  ArangoDBConnector.prototype.getDefaultIdType = function() {
    return String;
  };


  /*
    Get the model class for a certain model name
    @param model [String] The model name to lookup
    @return [Object] The model class of this model
   */

  ArangoDBConnector.prototype.getModelClass = function(model) {
    return this._models[model];
  };


  /*
    Get the collection name for a certain model name
    @param model [String] The model name to lookup
    @return [Object] The collection name for this model
   */

  ArangoDBConnector.prototype.getCollectionName = function(model) {
    var modelClass;
    modelClass = this.getModelClass(model);
    if (modelClass.settings && modelClass.settings.arangodb) {
      model = modelClass.settings.arangodb.collection || model;
    }
    return model;
  };


  /*
   */

  ArangoDBConnector.prototype.coerceId = function(model, id) {
    var idName, idProp, idValue;
    if (id == null) {
      return id;
    }
    idValue = id;
    idName = this.idName(model);
    idProp = this.getPropertyDefinition(model, idName);
    if (idProp && typeof idProp.type === 'function') {
      if (!(idValue instanceof idProp.type)) {
        idValue = idProp.type(id);
        if (idProp.type === Number && isNaN(id)) {
          idValue = id;
        }
      }
    }
    return idValue;
  };


  /*
   */

  ArangoDBConnector.prototype._isSpecialAttribute = function(attribute) {
    return attribute === '_key' || attribute === '_id' || attribute === '_rev' || attribute === '_from' || attribute === '_to';
  };


  /*
    Set value of specific field into data object
    @param data {Object} The data object
    @param field {String} The name of field to set
    @param value {Any} The value to set
   */

  ArangoDBConnector.prototype._setFieldValue = function(data, field, value) {
    if (data) {
      return data[field] = value;
    }
  };


  /*
    Verify if the collection is an edge collection
    @param model [String] The model name to lookup
    @return [Boolean] Return true if collection is edge false otherwise
   */

  ArangoDBConnector.prototype._isEdge = function(model) {
    var modelClass, settings;
    modelClass = this.getModelClass(model);
    settings = modelClass.settings;
    return settings && settings.arangodb && settings.arangodb.edge || false;
  };


  /*
  Verify if the collection is an vertex collection
  @param model [String] The model name to lookup
  @return [Boolean] Return true if collection is vertex false otherwise
   */

  ArangoDBConnector.prototype._isVertex = function(model) {
    var modelClass, settings;
    modelClass = this.getModelClass(model);
    settings = modelClass.settings;
    return settings && settings.arangodb && settings.arangodb.vertex || false;
  };


  /*
   */

  ArangoDBConnector.prototype._getNameOfProperty = function(model, p) {
    var key, prop, props;
    props = this.getModelClass(model).properties;
    for (key in props) {
      prop = props[key];
      if (prop[p]) {
        return key;
      } else {
        continue;
      }
    }
    return false;
  };


  /*
    Get if the model has _id field
    @param model [String] The model name to lookup
    @return [String|Boolean] Return name of _id or false if model not has _id field
   */

  ArangoDBConnector.prototype._fullIdName = function(model) {
    return this._getNameOfProperty(model, '_id');
  };


  /*
    Get if the model has _from field
    @param model [String] The model name to lookup
    @return [String|Boolean] Return name of _from or false if model not has _from field
   */

  ArangoDBConnector.prototype._fromName = function(model) {
    return this._getNameOfProperty(model, '_from');
  };


  /*
    Get if the model has _to field
    @param model [String] The model name to lookup
    @return [String|Boolean] Return name of _to or false if model not has _to field
   */

  ArangoDBConnector.prototype._toName = function(model) {
    return this._getNameOfProperty(model, '_to');
  };


  /*
    Access a ArangoDB collection by model name
    @param {String} model The model name
    @param callback [Function] The callback function
    @return {*}
   */

  ArangoDBConnector.prototype.getCollection = function(model) {
    var collection;
    if (!this.db) {
      throw new Error('ArangoDB connection is not established');
    }
    collection = ArangoDBConnector.collection;
    if (this._isEdge(model)) {
      collection = ArangoDBConnector.edgeCollection;
    }
    return this.db[collection](this.getCollectionName(model));
  };


  /*
    Converts the retrieved data from the database to JSON, based on the properties of a given model
    @param model [String] The model name to look up the properties
    @param data [Object] The data from DB
    @return [Object] The converted data as an JSON Object
   */

  ArangoDBConnector.prototype.fromDatabase = function(model, data) {
    var key, props, val;
    if (data == null) {
      return null;
    }
    props = this.getModelClass(model).properties;
    for (key in props) {
      val = props[key];
      if ((data[key] != null) && (val != null) && val.type === Buffer) {
        data[key] = new Buffer(data[key]);
      }
      if ((data[key] != null) && (val != null) && val.type === Date) {
        data[key] = new Date(data[key]);
      }
      if ((data[key] != null) && (val != null) && val.type === GeoPoint) {
        data[key] = new GeoPoint({
          lat: data[key].lat,
          lng: data[key].lng
        });
      }
    }
    return data;
  };


  /*
    Execute a ArangoDB command
   */

  ArangoDBConnector.prototype.execute = function(model, command) {
    var args, callback, context;
    args = [].slice.call(arguments, 2);
    callback = args[args.length - 1];
    context = {
      req: {
        command: command,
        params: args
      }
    };
    return this.notifyObserversAround('execute', context, (function(_this) {
      return function(context, done) {
        var bindVars, collection, q, query;
        if (_this.debug) {
          debug('ArangoDB: model=%s command=%s', model, command, args);
        }
        args[args.length - 1] = function(err, result) {
          if (err) {
            debug('Error: ', err);
          } else {
            context.res = result;
            debug('Result: ', result);
          }
          return done(err, result);
        };
        if (command === 'query') {
          query = context.req.params[0];
          bindVars = context.req.params[1];
          if (_this.debug) {
            if (typeof query.toAQL === 'function') {
              q = query.toAQL();
            } else {
              q = query;
            }
            debug("query: " + q + " bindVars: " + (JSON.stringify(bindVars)));
          }
          return _this.db.query.apply(_this.db, args);
        } else {
          collection = _this.getCollection(model);
          return collection[command].apply(collection, args);
        }
      };
    })(this), callback);
  };


  /*
    Checks the version of the ArangoDB
    @param callback [Function] The calback function, called with a (possible) error object and the server versio
   */

  ArangoDBConnector.prototype.getVersion = function(callback) {
    if (this.version != null) {
      return callback(null, this.version);
    } else {
      return this.api.get('version', function(err, result) {
        if (err) {
          callback(err);
        }
        this.version = result.body;
        return callback(null, this.version);
      });
    }
  };


  /*
    Create a new model instance for the given data
    @param model [String] The model name
    @param data [Object] The data to create
    @param callback [Function] The callback function, called with a (possible) error object and the created object's id
   */

  ArangoDBConnector.prototype.create = function(model, data, options, callback) {
    var fromName, fullIdName, id, idName, idValue, isEdge, toName;
    if (this.debug) {
      debug("create model " + model + " with data: " + (JSON.stringify(data)));
    }
    idValue = this.getIdValue(model, data);
    idName = this.idName(model);
    if ((idValue == null) || typeof idValue === 'undefined') {
      delete data[idName];
    } else {
      id = String(idValue);
      data._key = id;
      if (idName !== '_key') {
        delete data[idName];
      }
    }
    fullIdName = this._fullIdName(model);
    if (fullIdName) {
      delete data[fullIdName];
    }
    isEdge = this._isEdge(model);
    fromName = null;
    toName = null;
    if (isEdge) {
      fromName = this._fromName(model);
      data._from = data[fromName];
      if (fromName !== '_from') {
        delete data[fromName];
      }
      toName = this._toName(model);
      data._to = data[toName];
      if (toName !== '_to') {
        delete data[toName];
      }
    }
    return this.execute(model, 'save', data, (function(_this) {
      return function(err, result) {
        var fullIdValue;
        if (err) {
          if (err.errorNum === 1210) {
            err.message = '/duplicate/i';
          }
          return callback(err);
        }
        idValue = _this.coerceId(model, result._key);
        delete data._key;
        data[idName] = idValue;
        fullIdValue = result._id;
        if (isEdge) {
          if (fromName !== '_from') {
            data[fromName] = result._from;
          }
          if (toName !== '_to') {
            data[toName] = result._to;
          }
        }
        if (fullIdName) {
          data[fullIdName] = fullIdValue;
        }
        return callback(err, idValue);
      };
    })(this));
  };


  /*
    Update if the model instance exists with the same id or create a new instance
    @param model [String] The model name
    @param data [Object] The model instance data
    @param callback [Function] The callback function, called with a (possible) error object and updated or created object
   */

  ArangoDBConnector.prototype.updateOrCreate = function(model, data, options, callback) {
    var aql, bindVars, dataI, fromName, fullIdName, idName, idValue, isEdge, toName;
    if (this.debug) {
      debug("updateOrCreate for Model " + model + " with data: " + (JSON.stringify(data)));
    }
    this.getVersion(function(err, v) {
      var version;
      version = new RegExp(/[2-9]+\.[6-9]+\.[0-9]+/).test(v.version);
      if (err || !version) {
        err = new Error("Error updateOrCreate not supported for version {#v}");
        return callback(err);
      }
    });
    idValue = this.getIdValue(model, data);
    idName = this.idName(model);
    if (typeof idValue === 'number') {
      idValue = String(idValue);
    }
    delete data[idName];
    fullIdName = this._fullIdName(model);
    if (fullIdName === false) {
      delete data[fullIdName];
    }
    isEdge = this._isEdge(model);
    fromName = null;
    toName = null;
    if (isEdge) {
      fromName = this._fromName(model);
      data._from = data[fromName];
      if (fromName !== '_from') {
        delete data[fromName];
      }
      toName = this._toName(model);
      data._to = data[toName];
      if (toName !== '_to') {
        delete data[toName];
      }
    }
    dataI = _.clone(data);
    dataI._key = idValue;
    aql = qb.upsert({
      _key: '@id'
    }).insert('@dataI').update('@data')["in"]('@@collection')["let"]('isNewInstance', qb.ref('OLD').then(false)["else"](true))["return"]({
      doc: 'NEW',
      isNewInstance: 'isNewInstance'
    });
    bindVars = {
      '@collection': this.getCollectionName(model),
      id: idValue,
      dataI: dataI,
      data: data
    };
    return this.execute(model, 'query', aql, bindVars, (function(_this) {
      return function(err, result) {
        var isNewInstance, newDoc;
        if (result && result._result[0]) {
          newDoc = result._result[0].doc;
          delete newDoc._rev;
          if (fullIdName) {
            data[fullIdName] = newDoc._id;
            if (fullIdName !== '_id') {
              delete newDoc._id;
            }
          } else {
            delete newDoc._id;
          }
          if (isEdge) {
            if (fromName !== '_from') {
              data[fromName] = result._from;
            }
            if (toName !== '_to') {
              data[toName] = result._to;
            }
          }
          isNewInstance = {
            isNewInstance: result._result[0].isNewInstance
          };
          _this.setIdValue(model, data, newDoc._key);
          _this.setIdValue(model, newDoc, newDoc._key);
          if (idName !== '_key') {
            delete newDoc._key;
          }
        }
        return callback(err, newDoc, isNewInstance);
      };
    })(this));
  };


  /*
    Save the model instance for the given data
    @param model [String] The model name
    @param data [Object] The updated data to save or create
    @param options [Object]
    @param callback [Function] The callback function, called with a (possible) error object and the number of affected objects
   */

  ArangoDBConnector.prototype.save = ArangoDBConnector.prototype.updateOrCreate;


  /*
    Check if a model instance exists by id
    @param model [String] The model name
    @param id [String] The id value
    @param options [Object]
    @param callback [Function] The callback function, called with a (possible) error object and an boolean value if the specified object existed (true) or not (false)
   */

  ArangoDBConnector.prototype.exists = function(model, id, options, callback) {
    if (this.debug) {
      debug("exists for " + model + " with id: " + id);
    }
    return this.find(model, id, options, function(err, result) {
      if (err) {
        return callback(err);
      }
      return callback(null, result.length > 0);
    });
  };


  /*
    Find a model instance by id
    @param model [String] model The model name
    @param id [String] id The id value
    @param options [Object]
    @param callback [Function] The callback function, called with a (possible) error object and the found object
   */

  ArangoDBConnector.prototype.find = function(model, id, options, callback) {
    var command;
    if (this.debug) {
      debug("find for " + model + " with id: " + id);
    }
    command = 'document';
    if (this._isEdge(model)) {
      command = 'edge';
    }
    return this.execute(model, command, id, function(err, result) {
      if (err) {
        return callback(err);
      }
      return callback(null, result);
    });
  };


  /*
    Extracts where relevant information from the filter for a certain model
    @param [String] model The model name
    @param [Object] filter The filter object, also containing the where conditions
    @param [String] returnVariable The variable to build the where conditions on
    @return return [Object]
    @option return aqlArray [Array] The issued conditions as an array of AQL query builder objects
    @option return bindVars [Object] The variables, bound in the conditions
    @option return geoObject [Object] An query builder object containing possible parameters for a geo query
   */

  ArangoDBConnector.prototype._buildWhere = function(model, where, index) {
    var aqlArray, assignNewQueryVariable, bindVars, condProp, condValue, fn, fromName, fullIdName, geoExpr, idName, toName;
    if (this.debug) {
      debug("Evaluating where object " + (JSON.stringify(where)) + " for Model " + model);
    }
    if ((where == null) || typeof where !== 'object') {
      return;
    }
    aqlArray = [];
    bindVars = {};
    geoExpr = {};
    index = index || 0;
    assignNewQueryVariable = function(value) {
      var partName;
      partName = 'param_' + (index++);
      bindVars[partName] = value;
      return '@' + partName;
    };
    idName = this.idName(model);
    fullIdName = this._fullIdName(model);
    fromName = this._fromName(model);
    toName = this._toName(model);

    /*
      the where object comes in two flavors
    
       - where[prop] = value: this is short for "prop" equals "value"
       - where[prop][op] = value: this is the long version and stands for "prop" "op" "value"
     */
    fn = (function(_this) {
      return function() {
        var a, aql, c, collection, cond, condOp, lat, long, options, ref, value;
        if (condProp === 'and' || condProp === 'or' || condProp === 'nor') {
          if (Array.isArray(condValue)) {
            aql = qb;
            for (c in condValue) {
              a = condValue[c];
              cond = _this._buildWhere(model, a, ++index);
              aql = aql[condProp](cond.aqlArray[0]);
              bindVars = merge(true, bindVars, cond.bindVars);
            }
            aqlArray.push(aql);
            aql = null;
          }
          return;
        }
        if (condProp === idName) {
          condProp = '_key';
          if (typeof condValue === 'number') {
            condValue = String(condValue);
          }
        }
        if (condProp === fullIdName) {
          condProp = '_id';
        }
        if (condProp === fromName) {
          condProp = '_from';
        }
        if (condProp === toName) {
          condProp = '_to';
        }
        if (condValue && condValue.constructor.name === 'Object') {
          options = condValue.options;
          condOp = Object.keys(condValue)[0];
          condValue = condValue[condOp];
        }
        if (condOp) {
          switch (false) {
            case condOp !== 'lte' && condOp !== 'lt' && condOp !== 'gte' && condOp !== 'gt' && condOp !== 'eq' && condOp !== 'neq':
              return aqlArray.push(qb[condOp](_this.returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue))));
            case condOp !== 'between':
              return aqlArray.push([qb.gte(_this.returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue[0]))), qb.lte(_this.returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue[1])))]);
            case condOp !== 'like':
              if (options === 'i') {
                options = true;
              } else {
                options = false;
              }
              return aqlArray.push(qb.fn('LIKE')(_this.returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue)), options));
            case condOp !== 'nlike':
              if (options === 'i') {
                options = true;
              } else {
                options = false;
              }
              return aqlArray.push(qb.not(qb.fn('LIKE')(_this.returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue)), options)));
            case condOp !== 'nin':
              if (_this._isSpecialAttribute(condProp)) {
                condValue = (function() {
                  var i, len, results;
                  results = [];
                  for (i = 0, len = condValue.length; i < len; i++) {
                    value = condValue[i];
                    results.push(value.toString());
                  }
                  return results;
                })();
              }
              return aqlArray.push(qb.not(qb["in"](_this.returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue)))));
            case condOp !== 'inq':
              if (_this._isSpecialAttribute(condProp)) {
                condValue = (function() {
                  var i, len, results;
                  results = [];
                  for (i = 0, len = condValue.length; i < len; i++) {
                    value = condValue[i];
                    results.push(value.toString());
                  }
                  return results;
                })();
              }
              return aqlArray.push(qb["in"](_this.returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue))));
            case condOp !== 'near':
              ref = condValue.split(','), lat = ref[0], long = ref[1];
              collection = _this.getCollectionName(model);
              if (where.limit != null) {
                return geoExpr = qb.NEAR(collection, lat, long, where.limit);
              } else {
                return geoExpr = qb.NEAR(collection, lat, long);
              }
              break;
            default:
              return console.warn('No matching operator for : ', condOp);
          }
        } else {
          return aqlArray.push(qb.eq(_this.returnVariable + "." + condProp, "" + (assignNewQueryVariable(condValue))));
        }
      };
    })(this);
    for (condProp in where) {
      condValue = where[condProp];
      fn();
    }
    return {
      aqlArray: aqlArray,
      bindVars: bindVars,
      geoExpr: geoExpr
    };
  };


  /*
    Find matching model instances by the filter
    @param [String] model The model name
    @param [Object] filter The filter
    @param options [Object]
    @param [Function] callback Callback with (possible) error object or list of objects
   */

  ArangoDBConnector.prototype.all = function(model, filter, options, callback) {
    var aql, bindVars, field, fields, fromName, fullIdName, i, idName, indexFromName, indexFullId, indexId, indexToName, j, len, len1, m, order, ref, ref1, toName, w, where;
    if (this.debug) {
      debug("all for " + model + " with filter " + (JSON.stringify(filter)));
    }
    idName = this.idName(model);
    fullIdName = this._fullIdName(model);
    fromName = this._fromName(model);
    toName = this._toName(model);
    bindVars = {
      '@collection': this.getCollectionName(model)
    };
    aql = qb["for"](this.returnVariable)["in"]('@@collection');
    if (filter.where) {
      where = this._buildWhere(model, filter.where);
      ref = where.aqlArray;
      for (i = 0, len = ref.length; i < len; i++) {
        w = ref[i];
        aql = aql.filter(w);
      }
      merge(true, bindVars, where.bindVars);
    }
    if (filter.order) {
      if (typeof filter.order === 'string') {
        filter.order = filter.order.split(',');
      }
      ref1 = filter.order;
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        order = ref1[j];
        m = order.match(/\s+(A|DE)SC$/);
        field = order.replace(/\s+(A|DE)SC$/, '').trim();
        if (field === idName || field === fullIdName || field === fromName || field === toName) {
          switch (field) {
            case idName:
              field = '_key';
              break;
            case fullIdName:
              field = '_id';
              break;
            case fromName:
              field = '_from';
              break;
            case toName:
              field = '_to';
          }
        }
        if (m && m[1] === 'DE') {
          aql = aql.sort(this.returnVariable + '.' + field, 'DESC');
        } else {
          aql = aql.sort(this.returnVariable + '.' + field, 'ASC');
        }
      }
    } else if (!this.settings.disableDefaultSortByKey) {
      aql = aql.sort(this.returnVariable + '._key');
    }
    if (filter.limit) {
      aql = aql.limit(filter.skip, filter.limit);
    }
    fields = _.clone(filter.fields);
    if (fields) {
      indexId = fields.indexOf(idName);
      if (indexId !== -1) {
        fields[indexId] = '_key';
      }
      indexFullId = fields.indexOf(fullIdName);
      if (indexFullId !== -1) {
        fields[indexFullId] = '_id';
      }
      indexFromName = fields.indexOf(fromName);
      if (indexFromName !== -1) {
        fields[indexFromName] = '_from';
      }
      indexToName = fields.indexOf(toName);
      if (indexToName !== -1) {
        fields[indexToName] = '_to';
      }
      fields = (function() {
        var k, len2, results;
        results = [];
        for (k = 0, len2 = fields.length; k < len2; k++) {
          field = fields[k];
          results.push('"' + field + '"');
        }
        return results;
      })();
      aql = aql["return"](qb.fn('KEEP')(this.returnVariable, fields));
    } else {
      aql = aql["return"](qb.fn('UNSET')(this.returnVariable, ['"_rev"']));
    }
    return this.execute(model, 'query', aql, bindVars, (function(_this) {
      return function(err, cursor) {
        var cursorToArray;
        if (err) {
          return callback(err);
        }
        cursorToArray = function(r) {
          if (_fieldIncluded(filter.fields, idName)) {
            _this.setIdValue(model, r, r._key);
          }
          if (idName !== '_key') {
            delete r._key;
          }
          if (fullIdName) {
            if (_fieldIncluded(filter.fields, fullIdName)) {
              _this._setFieldValue(r, fullIdName, r._id);
            }
            if (fullIdName !== '_id' && idName !== '_id') {
              delete r._id;
            }
          } else {
            if (idName !== '_id') {
              delete r._id;
            }
          }
          if (_this._isEdge(model)) {
            if (_fieldIncluded(filter.fields, fromName)) {
              _this._setFieldValue(r, fromName, r._from);
            }
            if (fromName !== '_from') {
              delete r._from;
            }
            if (_fieldIncluded(filter.fields, toName)) {
              _this._setFieldValue(r, toName, r._to);
              if (toName !== '_to') {
                delete r._to;
              }
            }
          }
          return r = _this.fromDatabase(model, r);
        };
        return cursor.map(cursorToArray, function(err, result) {
          if (err) {
            return callback(err);
          }
          if (filter.include != null) {
            return _this._models[model].model.include(result, filter.include, options, callback);
          } else {
            return callback(null, result);
          }
        });
      };
    })(this));
  };


  /*
    Delete a model instance by id
    @param model [String] model The model name
    @param id [String] id The id value
    @param options [Object]
    @param callback [Function] The callback function, called with a (possible) error object and the number of affected objects
   */

  ArangoDBConnector.prototype.destroy = function(model, id, options, callback) {
    if (this.debug) {
      debug("delete for " + model + " with id " + id);
    }
    return this.execute(model, 'remove', id, function(err, result) {
      if (err && err.errorNum === 1202) {
        err = null;
      }
      return callback && callback(err, {
        count: result && !result.error ? 1 : 0
      });
    });
  };


  /*
    Delete all instances for the given model
    @param [String] model The model name
    @param [Object] [where] The filter for where
    @param options [Object]
    @param [Function] callback Callback with (possible) error object or the number of affected objects
   */

  ArangoDBConnector.prototype.destroyAll = function(model, where, options, callback) {
    var aql, bindVars, collection, i, len, ref, w;
    if (this.debug) {
      debug("destroyAll for " + model + " with where " + (JSON.stringify(where)));
    }
    if (!callback && typeof where === 'function') {
      callback = where;
      where = void 0;
    }
    collection = this.getCollectionName(model);
    bindVars = {
      '@collection': collection
    };
    aql = qb["for"](this.returnVariable)["in"]('@@collection');
    if (!_.isEmpty(where)) {
      where = this._buildWhere(model, where);
      ref = where.aqlArray;
      for (i = 0, len = ref.length; i < len; i++) {
        w = ref[i];
        aql = aql.filter(w);
      }
      merge(true, bindVars, where.bindVars);
    }
    aql = aql.remove(this.returnVariable)["in"]('@@collection');
    return this.execute(model, 'query', aql, bindVars, function(err, result) {
      return callback && callback(err, {
        count: result.extra.stats.writesExecuted
      });
    });
  };


  /*
    Count the number of instances for the given model
    @param [String] model The model name
    @param [Function] callback Callback with (possible) error object or the number of affected objects
    @param [Object] where The filter for where
   */

  ArangoDBConnector.prototype.count = function(model, where, options, callback) {
    var aql, bindVars, collection, i, len, ref, w;
    if (this.debug) {
      debug("count for " + model + " with where " + (JSON.stringify(where)));
    }
    collection = this.getCollectionName(model);
    bindVars = {
      '@collection': collection
    };
    aql = qb["for"](this.returnVariable)["in"]('@@collection');
    if (!_.isEmpty(where)) {
      where = this._buildWhere(model, where);
      ref = where.aqlArray;
      for (i = 0, len = ref.length; i < len; i++) {
        w = ref[i];
        aql = aql.filter(w);
      }
      merge(true, bindVars, where.bindVars);
    }
    aql = qb["let"]('count', aql["return"](this.returnVariable))["return"](qb.LENGTH('count'));
    return this.execute(model, 'query', aql, bindVars, function(err, result) {
      return callback(err, result._result[0]);
    });
  };


  /*
    Update properties for the model instance data
    @param [String] model The model name
    @param [String] id The models id
    @param [Object] data The model data
    @param [Object] options
    @param [Function] callback Callback with (possible) error object or the updated object
   */

  ArangoDBConnector.prototype.updateAttributes = function(model, id, data, options, callback) {
    var fromName, fullIdName, idName, isEdge, toName;
    if (this.debug) {
      debug("updateAttributes for " + model + " with id " + id + " and data " + (JSON.stringify(data)));
    }
    id = String(id);
    idName = this.idName(model);
    fullIdName = this._fullIdName(model);
    if (fullIdName) {
      delete data[fullIdName];
    }
    isEdge = this._isEdge(model);
    fromName = null;
    toName = null;
    if (isEdge) {
      fromName = this._fromName(model);
      delete data[fromName];
      toName = this._toName(model);
      delete data[toName];
    }
    return this.execute(model, 'update', id, data, options, (function(_this) {
      return function(err, result) {
        var fullIdValue;
        if (result) {
          delete result['_rev'];
          if (idName !== '_key') {
            delete result._key;
          }
          _this.setIdValue(model, result, id);
          if (fullIdName) {
            fullIdValue = result._id;
            delete result._id;
            result[fullIdName] = fullIdValue;
          }
          if (isEdge) {
            result[fromName] = result._from;
            result[toName] = result._to;
          }
        }
        return callback && callback(err, result);
      };
    })(this));
  };


  /*
    Update matching instance
    @param [String] model The model name
    @param [Object] where The search criteria
    @param [Object] data The property/value pairs to be updated
    @param [Object] options
    @param [Function] callback Callback with (possible) error object or the number of affected objects
   */

  ArangoDBConnector.prototype.update = function(model, where, data, options, callback) {
    var aql, bindVars, collection, fromName, fullIdName, i, idName, len, ref, toName, w;
    if (this.debug) {
      debug("updateAll for " + model + " with where " + (JSON.stringify(where)) + " and data " + (JSON.stringify(data)));
    }
    collection = this.getCollectionName(model);
    bindVars = {
      '@collection': collection,
      data: data
    };
    aql = qb["for"](this.returnVariable)["in"]('@@collection');
    if (where) {
      where = this._buildWhere(model, where);
      ref = where.aqlArray;
      for (i = 0, len = ref.length; i < len; i++) {
        w = ref[i];
        aql = aql.filter(w);
      }
      merge(true, bindVars, where.bindVars);
    }
    aql = aql.update(this.returnVariable)["with"]('@data')["in"]('@@collection');
    idName = this.idName(model);
    delete data[idName];
    fullIdName = this._fullIdName(model);
    if (fullIdName) {
      delete data[fullIdName];
    }
    if (this._isEdge(model)) {
      fromName = this._fromName(model);
      delete data[fromName];
      toName = this._toName(model);
      delete data[toName];
    }
    return this.execute(model, 'query', aql, bindVars, function(err, result) {
      if (err) {
        return callback(err);
      }
      return callback(null, {
        count: result.extra.stats.writesExecuted
      });
    });
  };


  /*
    Update all matching instances
   */

  ArangoDBConnector.prototype.updateAll = ArangoDBConnector.prototype.update;


  /*
    Perform autoupdate for the given models. It basically calls ensureIndex
    @param [String[]] [models] A model name or an array of model names. If not present, apply to all models
    @param [Function] [cb] The callback function
   */

  ArangoDBConnector.prototype.autoupdate = function(models, cb) {
    if (this.db) {
      if (this.debug) {
        debug('autoupdate for model %s', models);
      }
      if ((!cb) && (typeof models === 'function')) {
        cb = models;
        models = void 0;
      }
      if (typeof models === 'string') {
        models = [models];
      }
      models = models || Object.keys(this._models);
      return async.each(models, ((function(_this) {
        return function(model, modelCallback) {
          var index, indexList, indexName, indexes, options, propIdx, property, ref;
          indexes = _this._models[model].settings.indexes || [];
          indexList = [];
          index = {};
          options = {};
          if (typeof indexes === 'object') {
            for (indexName in indexes) {
              index = indexes[indexName];
              if (index.keys) {
                options = index.options || {};
                options.name = options.name || indexName;
                index.options = options;
              } else {
                options = {
                  name: indexName
                };
                index = {
                  keys: index,
                  options: options
                };
              }
              indexList.push(index);
            }
          } else if (Array.isArray(indexes)) {
            indexList = indexList.concat(indexes);
          }
          ref = _this._models[model].properties;
          for (propIdx in ref) {
            property = ref[propIdx];
            if (property.index) {
              index = {};
              index[propIdx] = 1;
              if (typeof property.index === 'object') {
                if (typeof property.index.arangodb === 'object') {
                  options = property.index.arangodb;
                  index[propIdx] = options.kind || 1;
                  if (property.index.uniqe === true) {
                    options.unique = true;
                  }
                } else {
                  options = property.index;
                }
                if (options.background === void 0) {
                  options.background = true;
                }
              } else {
                options = {
                  background: true
                };
                if (property.unique) {
                  options.unique = true;
                }
              }
              indexList.push({
                keys: index,
                options: options
              });
            }
          }
          if (_this.debug) {
            debug('create indexes');
          }
          return async.each(indexList, (function(index, indexCallback) {
            var collection;
            if (_this.debug) {
              debug('createIndex: %s', index);
            }
            collection = _this.getCollection(model);
            return collection.createIndex(index.fields || index.keys, index.options, indexCallback);
          }), modelCallback);
        };
      })(this)), cb);
    } else {
      return this.dataSource.once('connected', function() {
        return this.autoupdate(models, cb);
      });
    }
  };


  /*
    Perform automigrate for the given models. It drops the corresponding collections and calls ensureIndex
    @param [String[]] [models] A model name or an array of model names. If not present, apply to all models
    @param [Function] [cb] The callback function
   */

  ArangoDBConnector.prototype.automigrate = function(models, cb) {
    if (this.db) {
      if (this.debug) {
        debug("automigrate for model " + models);
      }
      if ((!cb) && (typeof models === 'function')) {
        cb = models;
        models = void 0;
      }
      if (typeof models === 'string') {
        models = [models];
      }
      models = models || Object.keys(this._models);
      return async.eachSeries(models, ((function(_this) {
        return function(model, modelCallback) {
          var collection, collectionName;
          collectionName = _this.getCollectionName(model);
          debug('drop collection %s for model %s', collectionName, model);
          collection = _this.getCollection(model);
          return collection.drop(function(err) {
            if (err) {
              if (err.response.body != null) {
                err = err.response.body;
                if (!(err.error === true && err.errorNum === 1203 && err.errorMessage === 'unknown collection \'' + model + '\'')) {
                  return modelCallback(err);
                }
              }
            }
            debug('create collection %s for model %s', collectionName, model);
            return collection.create(modelCallback);
          });
        };
      })(this)), ((function(_this) {
        return function(err) {
          return cb && cb(err);
          return _this.autoupdate(models, cb);
        };
      })(this)));
    } else {
      return this.dataSource.once('connected', function() {
        return this.automigrate(models(cb));
      });
    }
  };

  return ArangoDBConnector;

})(Connector);

ArangoDBConnector.collection = 'collection';

ArangoDBConnector.edgeCollection = 'edgeCollection';

exports.ArangoDBConnector = ArangoDBConnector;
